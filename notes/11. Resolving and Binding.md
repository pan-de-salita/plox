> [!NOTE]
>  In chapter 10, we introduced **dynamic scoping** by implementing closures. This causes a leak in the Lox interpreter. Begging the questions:
>  
>  - What is the nature of this leak?
>  - How do we patch it up?

# Key concepts
- Static scope
- Semantic analysis
- A resolver class
- Interpreting resolved variables
- Resolution errors

## Static scope
### Lexical scoping 
- Can figure out which declaration a variable name refers to just by reading the text of the program
- The scope rules are part of the static semantics of the language, which is why they're also called **static scope**

#### Scope rules
- A variable usage refers to the preceding declaration with the same name in the innermost scope that encloses the expression where the variable is used.

## Persistent environments
- Can never be directly modified. 
- Any modification to an existing structure produces a brand new object that contains all of the original data and the new modification.
- In Environments, every time a variable is defined, a *new* Environment is created to enclose:
	- All previously defined variables
	- The newly defined variable

### How does this fix our dynamic scoping bug?
A closure retains a reference to the Environment instance in play when the function was declared. Since any later declarations in that block would produce new Environment objects, the closure wouldn't see the new variables and our bug would be fixed.

> [!NOTE]
> This is the classic way to implement environments in Scheme interpreters.

Instead of making the data more statically structure, we'll bake the static resolution into the access operation itself.

## Semantic Analysis
- An implementation technique for variable resolution
- Tracks where each variable declaration is located and resolved a variable by referring to said location (distance between scopes)
- Differs from dynamic lookup -- which resolves a variable by dynamically looking up its declaration within scope hierarchies

If we could ensure a variable lookup always walked the same number of links in the environment chain, that would ensure that it found the same variable in the same scope every time.

To "resolve" a variable usage, we only need to calculate how many "hops" away the declared variable will be in the environment chain. 

Where to put this implementation? 

Since we're calculating a static property based on the structure of the source code, the traditional answer is in the parser. However, we'll be using a different technique.

## A Variable Resolution Pass
- Before our interpreter receives an AST to execute, we could do a single walk over the tree to resolve all of the variables it contains
- Work or passes are common between parsing and execution. 
- Any work that doesn't rely on state that's only available at runtime can be done this way.

Our variable resolution pass works like a sort of mini-interpreter. It walks the tree, visiting each node, but a static analysis is different from a dynamic execution:
- There are no side effects.
- There is no control flow.

## A Resolver Class


































